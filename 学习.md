# 私有属性
__private_attrs
self.__private_attrs
    __secretCount = 0  # 私有变量
    publicCount = 0    # 公开变量
    
    def __foo(self):          # 私有方法
        print('这是私有方法')
 
    def foo(self):            # 公共方法
        print('这是公共方法')
        self.__foo()
        
### 类的专有方法
__init__ : 构造函数，在生成对象时调用
__del__ : 析构函数，释放对象时使用
__repr__ : 打印，转换
__setitem__ : 按照索引赋值
__getitem__: 按照索引获取值
__len__: 获得长度
__cmp__: 比较运算
__call__: 函数调用
__add__: 加运算
__sub__: 减运算
__mul__: 乘运算
__truediv__: 除运算
__mod__: 求余运算
__pow__: 乘方


## 命名空间和作用域
1. 命名空间(Namespace)是从名称到对象的映射， 大部分的命名空间都是通过 Python 字典来实现的。
内置名称（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。
全局名称（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
局部名称（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）

2. 作用域就是一个 Python 程序可以直接访问命名空间的正文区域。
L（Local）：最内层，包含局部变量，比如一个函数/方法内部。
E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。
G（Global）：当前脚本的最外层，比如当前模块的全局变量。
B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。
规则顺序： L –> E –> G –> B。

```
#生成日历
import calendar
yy = int(input('请输入年份： '))
mm = int(input('请输入月份： '))
print(calendar.month(yy,mm))
```

```
# 计算最大公约数
def hcf(x,y):
    if x > y:
        smaller = y
    else:
        smaller = x
    for i in range(1,smaller + 1):
        if((x % i == 0) and (y % i == 0)):
            hcf = i
    return hcf
num1 = int(input('输入第一个数字： '))
num2 = int(input('输入第二个数字： '))

print(hcf(num1, num2))
```
```
#计算最小公倍数
def lcm(x, y):
    if x > y:
        smaller = x
    else:
        smaller = y
    while(True):
        if((smaller % x == 0) and (smaller % y == 0)):
            lcm = smaller
            break
        smaller += 1
    return lcm
num1 = int(input('输入第一个数字： '))
num2 = int(input('输入第二个数字： '))

print(lcm(num1, num2))
```
```
#计算数组的和
list = [1, 2, 4, 20, 23, 28]
sum = 0
for i in range(0, len(list)):
    sum += list[i]
print(sum)
```

## 查找
### 二分查找
```
def search(arr,l,r,x):
    if r >= 1:
        mid = int(l + (r - l)/2)
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return search(arr, l, mid-1, x)
        else:
            return search(arr,mid+1, r, x)
    else:
        return -1

arr = [2, 3, 4, 10, 40]
x = 10

result = search(arr, 0, len(arr) - 1,x)

if result != -1:
    print('元素在数组中的索引为 %d' % result)
else:
    print('元素不在数组中')
```
### 线性查分
### 插入排序 Insertion Sort
```
arr = [23, 13, 224, 10, 40,3]
def insertionSort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i -1
        while j >= 0 and key < arr[j]:
            arr[j+1] = arr[j]
            j -= 1
        arr[j + 1] = key
insertionSort(arr)
print('排序后的数组：')
for i in range(len(arr)):
    print('%d' %arr[i])
```
## 快速排序 Divide and conquer 把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。
挑选基准值 pivot
分割

def partition(arr,low,high):
    i = (low -1)
    pivot = arr[high]

    for j in range(low, high):
        if arr[j] <= pivot:
            i = i+1
            arr[i], arr[j] = arr[j],arr[i]
    arr[i+1],arr[high] = arr[high],arr[i + 1]
    return (i+1)

# arr[] --> 排序数组
# low  --> 起始索引
# high  --> 结束索引

def quickSort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)

        quickSort(arr, low, pi - 1)
        quickSort(arr, pi + 1, high)


arr = [10, 7, 8, 9, 1, 5]
n = len(arr)
quickSort(arr, 0, n - 1)
print("排序后的数组:")
for i in range(n):
    print("%d" % arr[i])

### 选择排序 Selection sort
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
```
import sys

A = [64, 25, 12, 22, 11]

for i in range(len(A)):

    min_idx = i
    for j in range(i + 1, len(A)):
        if A[min_idx] > A[j]:
            min_idx = j

    A[i], A[min_idx] = A[min_idx], A[i]

print("排序后的数组：")
for i in range(len(A)):
    print("%d" % A[i])
```
### 冒泡排序
它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来
```
def bubbleSort(arr):
    n = len(arr)

    # 遍历所有数组元素
    for i in range(n):

        # Last i elements are already in place
        for j in range(0, n - i - 1):

            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


arr = [64, 34, 25, 12, 22, 11, 90]

bubbleSort(arr)

print("排序后的数组:")
for i in range(len(arr)):
    print("%d" % arr[i])
```
### 归并排序
